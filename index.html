<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Gesture DJ Mixer</title>

  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
  <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

  <style>
    :root {
      --bg: #0a0a0a;
      --panel: #111;
      --accent: #00e5ff;
      --text: #eee;
      --muted: #555;
      --active: #00e5ff;
    }
    body {
      margin: 0;
      background: var(--bg);
      color: var(--text);
      font-family: ui-monospace, SFMono-Regular, Consolas, 'Courier New', monospace;
      overflow: hidden;
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      height: 100vh;
    }

    /* MAIN APP CONTAINER */
    #app {
      position: relative;
      width: min(1000px, 98vw);
      height: min(700px, 90vh);
      background: #000;
      border: 1px solid #333;
      border-radius: 12px;
      display: grid;
      grid-template-rows: 50px 1fr 150px;
      overflow: hidden;
      box-shadow: 0 0 50px rgba(0,0,0,0.8);
    }

    /* HEADER */
    header {
      z-index: 10;
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 0 20px;
      background: rgba(0,0,0,0.8);
      border-bottom: 1px solid #333;
    }
    .pill {
      background: #222;
      padding: 4px 10px;
      border-radius: 4px;
      font-size: 11px;
      border: 1px solid #444;
      display: flex; gap: 8px;
    }
    .status-dot { width: 8px; height: 8px; border-radius: 50%; background: #555; margin-top: 2px; }
    .status-dot.ok { background: #0f0; box-shadow: 0 0 5px #0f0; }
    .status-dot.err { background: #f00; }
    .accent { color: var(--accent); font-weight: bold; }

    /* VIDEO LAYER */
    #video-layer {
      position: relative;
      width: 100%;
      height: 100%;
      overflow: hidden;
      background: #050505;
    }
    canvas#output-canvas {
      display: block;
      width: 100%;
      height: 100%;
      object-fit: cover;
    }

    /* VISUAL GUIDES (OVERLAYS) */
    .guide-y {
      position: absolute;
      width: 40px;
      top: 60px;
      bottom: 160px;
      z-index: 5;
      display: flex;
      flex-direction: column-reverse;
      background: rgba(0,0,0,0.4);
      border: 1px solid rgba(255,255,255,0.1);
      pointer-events: none;
    }
    #guide-left { left: 20px; }
    #guide-right { right: 20px; }

    .guide-fill {
      width: 100%;
      background: var(--accent);
      opacity: 0.6;
      transition: height 0.1s;
    }
    .guide-label {
      position: absolute;
      bottom: -25px;
      width: 100%;
      text-align: center;
      font-size: 9px;
      color: var(--accent);
      font-weight: bold;
    }

    /* DASHBOARD (BOTTOM) */
    #dashboard {
      z-index: 10;
      background: rgba(15,15,15,0.95);
      backdrop-filter: blur(10px);
      border-top: 1px solid #333;
      padding: 10px;
      display: grid;
      grid-template-columns: repeat(5, 1fr);
      gap: 10px;
    }

    .deck {
      background: #111;
      border: 1px solid #333;
      border-radius: 6px;
      padding: 8px;
      display: flex;
      flex-direction: column;
      justify-content: space-between;
      transition: all 0.2s;
    }
    .deck.selected {
      border-color: var(--accent);
      background: rgba(0, 229, 255, 0.05);
      transform: translateY(-4px);
      box-shadow: 0 4px 12px rgba(0, 229, 255, 0.1);
    }
    .deck.active .led { background: var(--active); box-shadow: 0 0 8px var(--active); }
    .deck.muted { opacity: 0.4; }

    .deck-header { display: flex; justify-content: space-between; margin-bottom: 6px; }
    .deck-name { font-weight: 800; font-size: 14px; letter-spacing: 1px; }
    .led { width: 8px; height: 8px; border-radius: 50%; background: #333; transition: all 0.2s; }

    .meters { display: flex; gap: 4px; height: 100%; align-items: flex-end; }
    .meter-col { flex: 1; height: 100%; background: #222; position: relative; border-radius: 2px; overflow: hidden; }
    .meter-fill { position: absolute; bottom: 0; width: 100%; background: #666; height: 0%; transition: height 0.1s; }
    
    .meter-fill.fx { background: #ff0055; }
    .meter-fill.filt { background: var(--accent); }

    .labels { display: flex; justify-content: space-between; margin-top: 4px; font-size: 8px; color: #666; }

    /* START OVERLAY */
    #overlay {
      position: absolute; inset: 0;
      background: rgba(0,0,0,0.95);
      z-index: 100;
      display: flex; flex-direction: column; align-items: center; justify-content: center;
      cursor: pointer;
    }
    #overlay h1 { font-size: 2rem; color: var(--accent); margin: 0 0 10px 0; letter-spacing: 4px; }
    #overlay p { color: #888; margin: 5px 0; text-align: center; max-width: 400px; }
    #load-status { margin-top: 15px; color: #666; font-size: 12px; }

    /* HIDE RAW VIDEO BUT KEEP IN DOM */
    #input-video {
      position: absolute; top: 0; left: 0;
      opacity: 0; pointer-events: none; z-index: -1;
    }
  </style>
</head>
<body>

<div id="app">
  <header>
    <div class="pill">
      <div class="status-dot" id="cam-dot"></div>
      <span id="cam-status">INIT CAMERA...</span>
    </div>
    <div class="pill">HANDS: <span id="hand-status" class="accent">WAITING</span></div>
    <div class="pill">SELECTED: <span id="selected-status" class="accent">NONE</span></div>
  </header>

  <div id="guide-left" class="guide-y">
    <div class="guide-fill" id="fill-L" style="background: #ff0055;"></div>
    <div class="guide-label">FX SEND</div>
  </div>
  <div id="guide-right" class="guide-y">
    <div class="guide-fill" id="fill-R"></div>
    <div class="guide-label">FILTER</div>
  </div>

  <div id="video-layer">
    <canvas id="output-canvas"></canvas>
  </div>

  <div id="dashboard"></div>

  <div id="overlay">
    <h1>GESTURE DJ MIXER</h1>
    <p><strong>LEFT HAND:</strong> Each finger = mute/unmute track (thumb to pinky)</p>
    <p><strong>RIGHT HAND:</strong> Open one finger to select track, move up/down to control filter</p>
    <p><strong>LEFT HAND HEIGHT:</strong> Controls FX send for selected track</p>
    <div id="load-status">Ensure /assets/ folder has: kick.mp3, bass.mp3, hats.mp3, chord.mp3, vocals.mp3</div>
    <div id="load-status" style="margin-top: 10px; color: #888;">[ CLICK TO START ]</div>
  </div>
</div>

<video id="input-video" playsinline></video>

<script>
/**
 * AUDIO ENGINE - Sample Loader
 */
const AudioEngine = {
  ctx: null,
  master: null,
  loops: [],
  trackNames: ['KICK', 'BASS', 'HATS', 'CHORD', 'VOCALS'],
  files: ['kick.mp3', 'bass.mp3', 'hats.mp3', 'chord.mp3', 'vocals.mp3'],
  isPlaying: false,

  init: async function() {
    const AC = window.AudioContext || window.webkitAudioContext;
    this.ctx = new AC();
    this.master = this.ctx.createGain();
    this.master.gain.value = 0.8;
    this.master.connect(this.ctx.destination);

    // Global FX (Delay/Reverb)
    const delay = this.ctx.createDelay();
    delay.delayTime.value = 0.375; // 3/16th note delay
    const fb = this.ctx.createGain();
    fb.gain.value = 0.45;
    const dFilter = this.ctx.createBiquadFilter();
    dFilter.frequency.value = 1200; // darker echo

    delay.connect(fb);
    fb.connect(dFilter);
    dFilter.connect(delay);
    delay.connect(this.master);
    this.globalDelay = delay;

    // Load samples
    const statusEl = document.getElementById('load-status');
    statusEl.innerText = 'Loading samples...';
    statusEl.style.color = '#00e5ff';

    try {
      const buffers = await Promise.all(
        this.files.map(f => this.loadFile(`assets/${f}`))
      );

      // Create tracks
      buffers.forEach((buffer, i) => {
        this.createTrack(i, buffer);
      });

      statusEl.innerText = 'Audio ready! Click to start.';
      statusEl.style.color = '#0f0';
      this.isPlaying = true;
      return true;
    } catch (e) {
      statusEl.innerText = 'ERROR: Could not load samples from /assets/ folder';
      statusEl.style.color = '#f00';
      console.error('Audio loading error:', e);
      return false;
    }
  },

  loadFile: async function(url) {
    const response = await fetch(url);
    if (!response.ok) throw new Error(`Failed to load ${url}`);
    const arrayBuffer = await response.arrayBuffer();
    return await this.ctx.decodeAudioData(arrayBuffer);
  },

  createTrack: function(index, buffer) {
    // Audio chain: Source -> Filter -> Gain -> Master
    //                                    \-> Send -> Global FX
    const source = this.ctx.createBufferSource();
    source.buffer = buffer;
    source.loop = true;

    const filter = this.ctx.createBiquadFilter();
    filter.type = 'lowpass';
    filter.frequency.value = 20000; // fully open
    filter.Q.value = 1;

    const gain = this.ctx.createGain();
    gain.gain.value = 0; // start muted

    const send = this.ctx.createGain();
    send.gain.value = 0; // no FX initially

    // Connect chain
    source.connect(filter);
    filter.connect(gain);
    gain.connect(this.master);
    gain.connect(send);
    send.connect(this.globalDelay);

    // Start playback
    source.start(0);

    this.loops.push({
      name: this.trackNames[index],
      source,
      gain,
      filter,
      send,
      enabled: false,
      valFilter: 1.0,  // 0-1, controls filter cutoff
      valFx: 0.0       // 0-1, controls FX send
    });
  },

  update: function() {
    if (!this.isPlaying) return;
    const now = this.ctx.currentTime;

    this.loops.forEach(track => {
      // Smooth volume fade on mute/unmute
      const targetVol = track.enabled ? 1.0 : 0.0;
      track.gain.gain.setTargetAtTime(targetVol, now, 0.05);

      // Filter: exponential sweep from 100Hz to 20kHz
      const filterFreq = 100 * Math.pow(20000 / 100, track.valFilter);
      track.filter.frequency.setTargetAtTime(filterFreq, now, 0.1);

      // FX Send
      track.send.gain.setTargetAtTime(track.valFx, now, 0.1);
    });
  }
};

/**
 * APP STATE & UI
 */
const App = {
  selectedIdx: -1, // -1 means no selection
  leftToggles: [0, 0, 0, 0, 0], // timestamps for debouncing
  smoothL: 0, // left hand height (FX)
  smoothR: 1, // right hand height (Filter)

  init: function() {
    const dashboard = document.getElementById('dashboard');
    AudioEngine.trackNames.forEach((name, i) => {
      const el = document.createElement('div');
      el.className = 'deck';
      el.id = `deck-${i}`;
      el.innerHTML = `
        <div class="deck-header">
          <span class="deck-name">${name}</span>
          <div class="led" id="led-${i}"></div>
        </div>
        <div class="meters">
          <div class="meter-col"><div class="meter-fill fx" id="fill-fx-${i}"></div></div>
          <div class="meter-col"><div class="meter-fill filt" id="fill-filt-${i}" style="height:100%"></div></div>
        </div>
        <div class="labels"><span>FX</span><span>FLT</span></div>
      `;
      dashboard.appendChild(el);
    });
  },

  render: function() {
    // Update guide bars
    document.getElementById('fill-L').style.height = (this.smoothL * 100) + '%';
    document.getElementById('fill-R').style.height = (this.smoothR * 100) + '%';

    // Update selected display
    const selStatus = document.getElementById('selected-status');
    if (this.selectedIdx >= 0) {
      selStatus.innerText = AudioEngine.trackNames[this.selectedIdx];
      selStatus.style.color = '#00e5ff';
    } else {
      selStatus.innerText = 'NONE';
      selStatus.style.color = '#555';
    }

    // Update each deck
    AudioEngine.loops.forEach((track, i) => {
      const deck = document.getElementById(`deck-${i}`);

      // Active/muted state
      if (track.enabled) {
        deck.classList.remove('muted');
        deck.classList.add('active');
      } else {
        deck.classList.add('muted');
        deck.classList.remove('active');
      }

      // Selected state
      if (this.selectedIdx === i) {
        deck.classList.add('selected');
      } else {
        deck.classList.remove('selected');
      }

      // Update meters
      document.getElementById(`fill-fx-${i}`).style.height = (track.valFx * 100) + '%';
      document.getElementById(`fill-filt-${i}`).style.height = (track.valFilter * 100) + '%';
    });
  }
};

/**
 * CAMERA & GESTURE DETECTION
 */
const videoElement = document.getElementById('input-video');
const canvasElement = document.getElementById('output-canvas');
const canvasCtx = canvasElement.getContext('2d');
const camStatus = document.getElementById('cam-status');
const camDot = document.getElementById('cam-dot');

function onResults(results) {
  // Update canvas resolution if video size changed
  if (canvasElement.width !== videoElement.videoWidth) {
    canvasElement.width = videoElement.videoWidth;
    canvasElement.height = videoElement.videoHeight;
  }

  // Draw mirrored camera feed
  canvasCtx.save();
  canvasCtx.clearRect(0, 0, canvasElement.width, canvasElement.height);
  canvasCtx.translate(canvasElement.width, 0);
  canvasCtx.scale(-1, 1);
  canvasCtx.drawImage(results.image, 0, 0, canvasElement.width, canvasElement.height);

  let leftFound = false;
  let rightFound = false;

  if (results.multiHandLandmarks) {
    for (const [index, landmarks] of results.multiHandLandmarks.entries()) {
      const label = results.multiHandedness[index].label;

      // Draw hand skeleton
      drawConnectors(canvasCtx, landmarks, HAND_CONNECTIONS, {color: '#00e5ff', lineWidth: 2});
      drawLandmarks(canvasCtx, landmarks, {color: '#fff', lineWidth: 1, radius: 3});

      // Get wrist height (0 = bottom, 1 = top)
      const wristY = 1 - Math.max(0, Math.min(1, landmarks[0].y));

      // Detect which fingers are extended (simple Y-position check)
      const fingersOpen = [
        landmarks[4].x > landmarks[3].x, // Thumb (will be fixed per hand)
        landmarks[8].y < landmarks[6].y,  // Index
        landmarks[12].y < landmarks[10].y, // Middle
        landmarks[16].y < landmarks[14].y, // Ring
        landmarks[20].y < landmarks[18].y  // Pinky
      ];

      // Fix thumb logic based on hand side
      if (label === 'Left') {
        fingersOpen[0] = landmarks[4].x > landmarks[3].x;
      } else if (label === 'Right') {
        fingersOpen[0] = landmarks[4].x < landmarks[3].x;
      }

      // === LEFT HAND: Toggle mute/unmute ===
      if (label === 'Left') {
        leftFound = true;
        const now = Date.now();

        fingersOpen.forEach((isOpen, fingerIdx) => {
          if (isOpen) {
            if (!App.leftToggles[fingerIdx]) {
              App.leftToggles[fingerIdx] = now;
            } else if (now - App.leftToggles[fingerIdx] > 300) {
              // Toggle track
              if (AudioEngine.loops[fingerIdx]) {
                AudioEngine.loops[fingerIdx].enabled = !AudioEngine.loops[fingerIdx].enabled;
              }
              App.leftToggles[fingerIdx] = now + 999999; // Lock to prevent re-trigger
            }
          } else {
            App.leftToggles[fingerIdx] = 0; // Reset
          }
        });

        // Left hand height controls FX send for SELECTED track
        App.smoothL = App.smoothL * 0.8 + wristY * 0.2;
        if (App.selectedIdx >= 0 && AudioEngine.loops[App.selectedIdx]) {
          AudioEngine.loops[App.selectedIdx].valFx = App.smoothL;
        }
      }

      // === RIGHT HAND: Select track + control filter ===
      if (label === 'Right') {
        rightFound = true;

        // Selection: find first open finger (or -1 if none)
        const firstOpen = fingersOpen.indexOf(true);
        App.selectedIdx = firstOpen;

        // Right hand height controls filter for SELECTED track
        App.smoothR = App.smoothR * 0.8 + wristY * 0.2;
        if (App.selectedIdx >= 0 && AudioEngine.loops[App.selectedIdx]) {
          AudioEngine.loops[App.selectedIdx].valFilter = App.smoothR;
        }
      }
    }
  }

  canvasCtx.restore();

  // Update hand detection status
  const handStatus = document.getElementById('hand-status');
  if (leftFound && rightFound) {
    handStatus.innerText = 'LOCKED';
    handStatus.style.color = '#00e5ff';
  } else if (leftFound || rightFound) {
    handStatus.innerText = 'PARTIAL';
    handStatus.style.color = 'orange';
  } else {
    handStatus.innerText = 'SEARCHING...';
    handStatus.style.color = '#555';
  }

  // Update audio and UI
  AudioEngine.update();
  App.render();
}

/**
 * INITIALIZATION
 */
async function startSystem() {
  const overlay = document.getElementById('overlay');
  overlay.style.display = 'none';

  // Initialize UI
  App.init();

  // Initialize and load audio
  const audioOk = await AudioEngine.init();
  if (!audioOk) {
    alert('Failed to load audio samples. Check console for details.');
    return;
  }

  // Start camera
  camStatus.innerText = 'STARTING VIDEO...';

  const hands = new Hands({
    locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`
  });
  hands.setOptions({
    maxNumHands: 2,
    modelComplexity: 1,
    minDetectionConfidence: 0.5,
    minTrackingConfidence: 0.5
  });
  hands.onResults(onResults);

  const camera = new Camera(videoElement, {
    onFrame: async () => {
      await hands.send({ image: videoElement });
    },
    width: 1280,
    height: 720
  });

  try {
    await camera.start();
    camStatus.innerText = 'RUNNING';
    camDot.classList.add('ok');
  } catch (e) {
    camStatus.innerText = 'ERROR: ' + e.message;
    camDot.classList.add('err');
    console.error('Camera error:', e);
  }
}

document.getElementById('overlay').addEventListener('click', startSystem);
</script>
</body>
</html>